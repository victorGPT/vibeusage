// Generated by scripts/build-insforge-functions.cjs. DO NOT EDIT.

"use strict";
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// insforge-src/shared/http.js
var require_http = __commonJS({
  "insforge-src/shared/http.js"(exports2, module2) {
    "use strict";
    var corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization, apikey"
    };
    function handleOptions2(request) {
      if (request.method === "OPTIONS") {
        return new Response(null, { status: 204, headers: corsHeaders });
      }
      return null;
    }
    function json2(body, status = 200, extraHeaders = null) {
      return new Response(JSON.stringify(body), {
        status,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json",
          ...extraHeaders || {}
        }
      });
    }
    function requireMethod2(request, method) {
      if (request.method !== method) return json2({ error: "Method not allowed" }, 405);
      return null;
    }
    async function readJson2(request) {
      if (!request.headers.get("Content-Type")?.includes("application/json")) {
        return { error: "Content-Type must be application/json", status: 415, data: null };
      }
      try {
        const data = await request.json();
        return { error: null, status: 200, data };
      } catch (_e) {
        return { error: "Invalid JSON", status: 400, data: null };
      }
    }
    module2.exports = {
      corsHeaders,
      handleOptions: handleOptions2,
      json: json2,
      requireMethod: requireMethod2,
      readJson: readJson2
    };
  }
});

// insforge-src/shared/env.js
var require_env = __commonJS({
  "insforge-src/shared/env.js"(exports2, module2) {
    "use strict";
    function getBaseUrl2() {
      return Deno.env.get("INSFORGE_INTERNAL_URL") || "http://insforge:7130";
    }
    function getServiceRoleKey2() {
      return Deno.env.get("INSFORGE_SERVICE_ROLE_KEY") || Deno.env.get("SERVICE_ROLE_KEY") || Deno.env.get("INSFORGE_API_KEY") || Deno.env.get("API_KEY") || null;
    }
    function getAnonKey2() {
      return Deno.env.get("ANON_KEY") || Deno.env.get("INSFORGE_ANON_KEY") || null;
    }
    module2.exports = {
      getBaseUrl: getBaseUrl2,
      getServiceRoleKey: getServiceRoleKey2,
      getAnonKey: getAnonKey2
    };
  }
});

// insforge-src/shared/auth.js
var require_auth = __commonJS({
  "insforge-src/shared/auth.js"(exports2, module2) {
    "use strict";
    var { getAnonKey: getAnonKey2 } = require_env();
    function getBearerToken2(headerValue) {
      if (!headerValue) return null;
      const prefix = "Bearer ";
      if (!headerValue.startsWith(prefix)) return null;
      const token = headerValue.slice(prefix.length).trim();
      return token.length > 0 ? token : null;
    }
    async function getEdgeClientAndUserId({ baseUrl, bearer }) {
      const anonKey = getAnonKey2();
      const edgeClient = createClient({ baseUrl, anonKey: anonKey || void 0, edgeFunctionToken: bearer });
      const { data: userData, error: userErr } = await edgeClient.auth.getCurrentUser();
      const userId = userData?.user?.id;
      if (userErr || !userId) return { ok: false, edgeClient: null, userId: null };
      return { ok: true, edgeClient, userId };
    }
    module2.exports = {
      getBearerToken: getBearerToken2,
      getEdgeClientAndUserId
    };
  }
});

// insforge-src/shared/crypto.js
var require_crypto = __commonJS({
  "insforge-src/shared/crypto.js"(exports2, module2) {
    "use strict";
    async function sha256Hex2(input) {
      const data = new TextEncoder().encode(input);
      const hash = await crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    module2.exports = {
      sha256Hex: sha256Hex2
    };
  }
});

// insforge-src/shared/source.js
var require_source = __commonJS({
  "insforge-src/shared/source.js"(exports2, module2) {
    "use strict";
    var MAX_SOURCE_LENGTH = 64;
    function normalizeSource2(value) {
      if (typeof value !== "string") return null;
      const normalized = value.trim().toLowerCase();
      if (!normalized) return null;
      if (normalized.length > MAX_SOURCE_LENGTH) return normalized.slice(0, MAX_SOURCE_LENGTH);
      return normalized;
    }
    function getSourceParam(url) {
      if (!url || typeof url.searchParams?.get !== "function") {
        return { ok: false, error: "Invalid request URL" };
      }
      const raw = url.searchParams.get("source");
      if (raw == null) return { ok: true, source: null };
      const normalized = normalizeSource2(raw);
      if (!normalized) return { ok: false, error: "Invalid source" };
      return { ok: true, source: normalized };
    }
    module2.exports = {
      MAX_SOURCE_LENGTH,
      normalizeSource: normalizeSource2,
      getSourceParam
    };
  }
});

// insforge-src/functions/vibescore-ingest.js
var { handleOptions, json, requireMethod, readJson } = require_http();
var { getBearerToken } = require_auth();
var { getAnonKey, getBaseUrl, getServiceRoleKey } = require_env();
var { sha256Hex } = require_crypto();
var { normalizeSource } = require_source();
var MAX_BUCKETS = 500;
module.exports = async function(request) {
  const opt = handleOptions(request);
  if (opt) return opt;
  const methodErr = requireMethod(request, "POST");
  if (methodErr) return methodErr;
  const deviceToken = getBearerToken(request.headers.get("Authorization"));
  if (!deviceToken) return json({ error: "Missing bearer token" }, 401);
  const baseUrl = getBaseUrl();
  const serviceRoleKey = getServiceRoleKey();
  const anonKey = getAnonKey();
  const serviceClient = serviceRoleKey ? createClient({
    baseUrl,
    anonKey: anonKey || serviceRoleKey,
    edgeFunctionToken: serviceRoleKey
  }) : null;
  const tokenHash = await sha256Hex(deviceToken);
  let tokenRow = null;
  try {
    tokenRow = serviceClient ? await getTokenRowWithServiceClient(serviceClient, tokenHash) : await getTokenRowWithAnonKey({ baseUrl, anonKey, tokenHash });
  } catch (e) {
    return json({ error: e?.message || "Internal error" }, 500);
  }
  if (!tokenRow) return json({ error: "Unauthorized" }, 401);
  const body = await readJson(request);
  if (body.error) return json({ error: body.error }, body.status);
  const hourly = normalizeHourly(body.data);
  if (!Array.isArray(hourly)) {
    return json({ error: "Invalid payload: expected {hourly:[...]} or [...]" }, 400);
  }
  if (hourly.length > MAX_BUCKETS) return json({ error: `Too many buckets (max ${MAX_BUCKETS})` }, 413);
  const nowIso = (/* @__PURE__ */ new Date()).toISOString();
  const rows = buildRows({ hourly, tokenRow, nowIso });
  if (rows.error) return json({ error: rows.error }, 400);
  if (rows.data.length === 0) {
    return json({ success: true, inserted: 0, skipped: 0 }, 200);
  }
  const upsert = serviceClient ? await upsertWithServiceClient({
    serviceClient,
    tokenRow,
    rows: rows.data,
    nowIso,
    baseUrl,
    serviceRoleKey,
    tokenHash
  }) : await upsertWithAnonKey({ baseUrl, anonKey, tokenHash, tokenRow, rows: rows.data, nowIso });
  if (!upsert.ok) return json({ error: upsert.error }, 500);
  return json(
    {
      success: true,
      inserted: upsert.inserted,
      skipped: upsert.skipped
    },
    200
  );
};
function buildRows({ hourly, tokenRow, nowIso }) {
  const byHour = /* @__PURE__ */ new Map();
  for (const raw of hourly) {
    const parsed = parseHourlyBucket(raw);
    if (!parsed.ok) return { error: parsed.error, data: [] };
    const source = parsed.value.source || "codex";
    const dedupeKey = `${parsed.value.hour_start}::${source}`;
    byHour.set(dedupeKey, { ...parsed.value, source });
  }
  const rows = [];
  for (const bucket of byHour.values()) {
    rows.push({
      user_id: tokenRow.user_id,
      device_id: tokenRow.device_id,
      device_token_id: tokenRow.id,
      source: bucket.source,
      hour_start: bucket.hour_start,
      input_tokens: bucket.input_tokens,
      cached_input_tokens: bucket.cached_input_tokens,
      output_tokens: bucket.output_tokens,
      reasoning_output_tokens: bucket.reasoning_output_tokens,
      total_tokens: bucket.total_tokens,
      updated_at: nowIso
    });
  }
  return { error: null, data: rows };
}
async function getTokenRowWithServiceClient(serviceClient, tokenHash) {
  const { data: tokenRow, error: tokenErr } = await serviceClient.database.from("vibescore_tracker_device_tokens").select("id,user_id,device_id,revoked_at,last_sync_at").eq("token_hash", tokenHash).maybeSingle();
  if (tokenErr) throw new Error(tokenErr.message);
  if (!tokenRow || tokenRow.revoked_at) return null;
  return tokenRow;
}
async function getTokenRowWithAnonKey({ baseUrl, anonKey, tokenHash }) {
  if (!anonKey) throw new Error("Anon key missing");
  const url = new URL("/api/database/records/vibescore_tracker_device_tokens", baseUrl);
  url.searchParams.set("select", "id,user_id,device_id,revoked_at,last_sync_at");
  url.searchParams.set("token_hash", `eq.${tokenHash}`);
  url.searchParams.set("limit", "1");
  const res = await fetch(url.toString(), {
    method: "GET",
    headers: buildAnonHeaders({ anonKey, tokenHash })
  });
  const { data, error } = await readApiJson(res);
  if (!res.ok) throw new Error(error || `HTTP ${res.status}`);
  const rows = normalizeRows(data);
  const tokenRow = rows?.[0] || null;
  if (!tokenRow || tokenRow.revoked_at) return null;
  return tokenRow;
}
async function upsertWithServiceClient({
  serviceClient,
  tokenRow,
  rows,
  nowIso,
  baseUrl,
  serviceRoleKey,
  tokenHash
}) {
  if (serviceRoleKey && baseUrl) {
    const url = new URL("/api/database/records/vibescore_tracker_hourly", baseUrl);
    const res = await recordsUpsert({
      url,
      anonKey: serviceRoleKey,
      tokenHash,
      rows,
      onConflict: "user_id,device_id,source,hour_start",
      prefer: "return=representation",
      resolution: "merge-duplicates",
      select: "hour_start"
    });
    if (res.ok) {
      const insertedRows = normalizeRows(res.data);
      const inserted = Array.isArray(insertedRows) ? insertedRows.length : rows.length;
      await bestEffortTouchWithServiceClient(serviceClient, tokenRow, nowIso);
      return { ok: true, inserted, skipped: 0 };
    }
    if (!isUpsertUnsupported(res)) {
      return { ok: false, error: res.error || `HTTP ${res.status}`, inserted: 0, skipped: 0 };
    }
  }
  const table = serviceClient.database.from("vibescore_tracker_hourly");
  if (typeof table?.upsert === "function") {
    const { error } = await table.upsert(rows, { onConflict: "user_id,device_id,source,hour_start" });
    if (error) return { ok: false, error: error.message, inserted: 0, skipped: 0 };
    await bestEffortTouchWithServiceClient(serviceClient, tokenRow, nowIso);
    return { ok: true, inserted: rows.length, skipped: 0 };
  }
  return { ok: false, error: "Half-hour upsert unsupported", inserted: 0, skipped: 0 };
}
async function upsertWithAnonKey({ baseUrl, anonKey, tokenHash, tokenRow, rows, nowIso }) {
  if (!anonKey) return { ok: false, error: "Anon key missing", inserted: 0, skipped: 0 };
  const url = new URL("/api/database/records/vibescore_tracker_hourly", baseUrl);
  const res = await recordsUpsert({
    url,
    anonKey,
    tokenHash,
    rows,
    onConflict: "user_id,device_id,source,hour_start",
    prefer: "return=representation",
    resolution: "merge-duplicates",
    select: "hour_start"
  });
  if (res.ok) {
    const insertedRows = normalizeRows(res.data);
    const inserted = Array.isArray(insertedRows) ? insertedRows.length : rows.length;
    await bestEffortTouchWithAnonKey({ baseUrl, anonKey, tokenHash, nowIso });
    return { ok: true, inserted, skipped: 0 };
  }
  if (isUpsertUnsupported(res)) {
    return { ok: false, error: res.error || "Half-hour upsert unsupported", inserted: 0, skipped: 0 };
  }
  return { ok: false, error: res.error || `HTTP ${res.status}`, inserted: 0, skipped: 0 };
}
async function bestEffortTouchWithServiceClient(serviceClient, tokenRow, nowIso) {
  const lastSyncAt = normalizeIso(tokenRow?.last_sync_at);
  const shouldUpdateSync = !lastSyncAt || !isWithinInterval(lastSyncAt, 30);
  try {
    await serviceClient.database.from("vibescore_tracker_device_tokens").update(shouldUpdateSync ? { last_used_at: nowIso, last_sync_at: nowIso } : { last_used_at: nowIso }).eq("id", tokenRow.id);
  } catch (_e) {
  }
  try {
    await serviceClient.database.from("vibescore_tracker_devices").update({ last_seen_at: nowIso }).eq("id", tokenRow.device_id);
  } catch (_e) {
  }
}
async function bestEffortTouchWithAnonKey({ baseUrl, anonKey, tokenHash }) {
  if (!anonKey) return;
  try {
    const url = new URL("/api/database/rpc/vibescore_touch_device_token_sync", baseUrl);
    await fetch(url.toString(), {
      method: "POST",
      headers: {
        ...buildAnonHeaders({ anonKey, tokenHash }),
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ min_interval_minutes: 30 })
    });
  } catch (_e) {
  }
}
function buildAnonHeaders({ anonKey, tokenHash }) {
  return {
    apikey: anonKey,
    Authorization: `Bearer ${anonKey}`,
    "x-vibescore-device-token-hash": tokenHash
  };
}
async function recordsUpsert({ url, anonKey, tokenHash, rows, onConflict, prefer, resolution, select }) {
  const target = new URL(url.toString());
  if (onConflict) target.searchParams.set("on_conflict", onConflict);
  if (select) target.searchParams.set("select", select);
  const preferParts = [];
  if (prefer) preferParts.push(prefer);
  if (resolution) preferParts.push(`resolution=${resolution}`);
  const preferHeader = preferParts.filter(Boolean).join(",");
  const res = await fetch(target.toString(), {
    method: "POST",
    headers: {
      ...buildAnonHeaders({ anonKey, tokenHash }),
      ...preferHeader ? { Prefer: preferHeader } : {},
      "Content-Type": "application/json"
    },
    body: JSON.stringify(rows)
  });
  const { data, error, code } = await readApiJson(res);
  return { ok: res.ok, status: res.status, data, error, code };
}
async function readApiJson(res) {
  const text = await res.text();
  if (!text) return { data: null, error: null, code: null };
  try {
    const parsed = JSON.parse(text);
    return { data: parsed, error: parsed?.message || parsed?.error || null, code: parsed?.code || null };
  } catch (_e) {
    return { data: null, error: text.slice(0, 300), code: null };
  }
}
function normalizeRows(data) {
  if (Array.isArray(data)) return data;
  if (data && typeof data === "object" && Array.isArray(data.data)) return data.data;
  return null;
}
function normalizeIso(value) {
  if (typeof value !== "string") return null;
  const dt = new Date(value);
  if (!Number.isFinite(dt.getTime())) return null;
  return dt.toISOString();
}
function isWithinInterval(lastSyncAt, minutes) {
  const lastMs = Date.parse(lastSyncAt);
  if (!Number.isFinite(lastMs)) return false;
  const windowMs = Math.max(0, minutes) * 60 * 1e3;
  return windowMs > 0 && Date.now() - lastMs < windowMs;
}
function isUpsertUnsupported(result) {
  const status = Number(result?.status || 0);
  if (status !== 400 && status !== 404 && status !== 405 && status !== 409 && status !== 422) return false;
  const msg = String(result?.error || "").toLowerCase();
  if (!msg) return false;
  return msg.includes("on_conflict") || msg.includes("resolution") || msg.includes("prefer") || msg.includes("unknown") || msg.includes("invalid");
}
function normalizeHourly(data) {
  if (Array.isArray(data)) return data;
  if (data && typeof data === "object") {
    if (Array.isArray(data.hourly)) return data.hourly;
    if (Array.isArray(data.data)) return data.data;
    if (data.data && typeof data.data === "object" && Array.isArray(data.data.hourly)) {
      return data.data.hourly;
    }
  }
  return null;
}
function parseHourlyBucket(raw) {
  if (!raw || typeof raw !== "object") return { ok: false, error: "Invalid half-hour bucket" };
  const hourStart = parseUtcHalfHourStart(raw.hour_start);
  if (!hourStart) {
    return { ok: false, error: "hour_start must be an ISO timestamp at UTC half-hour boundary" };
  }
  const source = normalizeSource(raw.source);
  const input = toNonNegativeInt(raw.input_tokens);
  const cached = toNonNegativeInt(raw.cached_input_tokens);
  const output = toNonNegativeInt(raw.output_tokens);
  const reasoning = toNonNegativeInt(raw.reasoning_output_tokens);
  const total = toNonNegativeInt(raw.total_tokens);
  if ([input, cached, output, reasoning, total].some((n) => n == null)) {
    return { ok: false, error: "Token fields must be non-negative integers" };
  }
  return {
    ok: true,
    value: {
      source,
      hour_start: hourStart,
      input_tokens: input,
      cached_input_tokens: cached,
      output_tokens: output,
      reasoning_output_tokens: reasoning,
      total_tokens: total
    }
  };
}
function parseUtcHalfHourStart(value) {
  if (typeof value !== "string" || value.trim() === "") return null;
  const dt = new Date(value);
  if (!Number.isFinite(dt.getTime())) return null;
  const minutes = dt.getUTCMinutes();
  if (minutes !== 0 && minutes !== 30 || dt.getUTCSeconds() !== 0 || dt.getUTCMilliseconds() !== 0) {
    return null;
  }
  const hourStart = new Date(
    Date.UTC(
      dt.getUTCFullYear(),
      dt.getUTCMonth(),
      dt.getUTCDate(),
      dt.getUTCHours(),
      minutes >= 30 ? 30 : 0,
      0,
      0
    )
  );
  return hourStart.toISOString();
}
function toNonNegativeInt(n) {
  if (typeof n !== "number") return null;
  if (!Number.isFinite(n)) return null;
  if (!Number.isInteger(n)) return null;
  if (n < 0) return null;
  return n;
}
