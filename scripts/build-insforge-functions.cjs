#!/usr/bin/env node
'use strict';

const fs = require('node:fs/promises');
const path = require('node:path');

async function main() {
  const args = new Set(process.argv.slice(2));
  const check = args.has('--check');
  if (args.has('--help') || args.has('-h')) {
    process.stdout.write(
      [
        'Usage:',
        '  node scripts/build-insforge-functions.cjs [--check]',
        '',
        'Outputs:',
        '  insforge-functions/*.js (single-file deploy artifacts)',
        '',
        'Notes:',
        '  - Sources live in insforge-src/functions/*.js',
        '  - Artifacts are generated and should not be edited by hand.',
        ''
      ].join('\n')
    );
    return;
  }

  const rootDir = path.resolve(__dirname, '..');
  const srcDir = path.join(rootDir, 'insforge-src', 'functions');
  const outDir = path.join(rootDir, 'insforge-functions');

  const entryPoints = await listEntryPoints(srcDir);
  if (entryPoints.length === 0) {
    throw new Error(`No entry points found under ${path.relative(rootDir, srcDir)}/`);
  }

  const esbuild = require('esbuild');

  const result = await esbuild.build({
    entryPoints,
    outdir: outDir,
    entryNames: '[name]',
    bundle: true,
    format: 'cjs',
    platform: 'neutral',
    target: ['es2020'],
    sourcemap: false,
    legalComments: 'none',
    banner: {
      js: '// Generated by scripts/build-insforge-functions.cjs. DO NOT EDIT.\n'
    },
    logLevel: 'silent',
    write: !check
  });

  if (!check) {
    process.stdout.write(`Built ${entryPoints.length} InsForge edge functions into ${path.relative(rootDir, outDir)}/\n`);
    return;
  }

  const problems = await diffOutputs({ rootDir, outDir, outputFiles: result.outputFiles || [] });
  if (problems.length > 0) {
    process.stderr.write('insforge-functions is out of date:\n');
    for (const p of problems) process.stderr.write(`- ${p}\n`);
    process.exitCode = 1;
    return;
  }

  process.stdout.write('insforge-functions is up to date.\n');
}

async function listEntryPoints(srcDir) {
  const entries = await fs.readdir(srcDir, { withFileTypes: true }).catch(() => []);
  return entries
    .filter((e) => e.isFile() && e.name.endsWith('.js'))
    .map((e) => path.join(srcDir, e.name))
    .sort();
}

async function diffOutputs({ rootDir, outDir, outputFiles }) {
  const problems = [];
  for (const out of outputFiles) {
    const rel = path.relative(rootDir, out.path);
    if (!rel.startsWith(`insforge-functions${path.sep}`)) continue;

    const disk = await fs.readFile(out.path).catch(() => null);
    if (!disk) {
      problems.push(`${rel} (missing)`);
      continue;
    }
    if (!buffersEqual(disk, out.contents)) {
      problems.push(`${rel} (differs)`);
    }
  }

  const expected = new Set(
    outputFiles
      .map((o) => path.relative(outDir, o.path))
      .filter((p) => p && !p.includes('..') && p.endsWith('.js'))
  );
  const existing = await fs.readdir(outDir, { withFileTypes: true }).catch(() => []);
  for (const e of existing) {
    if (!e.isFile() || !e.name.endsWith('.js')) continue;
    if (!expected.has(e.name)) {
      problems.push(`${path.join('insforge-functions', e.name)} (unexpected file)`);
    }
  }

  return problems;
}

function buffersEqual(a, b) {
  if (!a || !b) return false;
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

main().catch((err) => {
  process.stderr.write(`${err && err.stack ? err.stack : String(err)}\n`);
  process.exitCode = 1;
});

